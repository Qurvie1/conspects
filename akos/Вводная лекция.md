Из каких компонент состоит компьютер?
+ Центральный процессор (CPU или ЦП)
+ Чипсет и материнская плата
+ Оперативная память (Random Access Memory = RAM)
+ Накопители (HDD, SSD, NVMe)
+ Аудиокарты
+ Сетевая карты
+ GPU
+ Шины (PCI, I2C, ISA)
+ Таймеры
+ USB хабы

**Процессор**
+ Исполняет команды или инструкции
+ Регистры – самая быстрые доступные ячейки памяти
+ Размер регистров определяют раздрядность процессора

**Оперативная память**
+ Random Access Memory
+ Адресное пространство – непрерывный массив байт от 0 до $2^{N}$, где N –
  разрядность процессора (64 бита)
+ В реальности процессоры на текущий момент обычно адресуют не более 48
  бит (256 террабайт)
+ Виртуальная память и физическая – два разных адресных пространства
  ОС может управлять виртуальной памятью

**Процессор и периферия**
+ Процессор общается с оперативной памятью и устройствами по специальным
  шинам
+ Шины – не просто провода, это сложные системы + спецификации
+ Обычно устройства выглядят как специальные адреса в памяти
  Например, HPET (High Precision Event Timer) обычно управляется по
  физическому адресу 0xfed00000
+ Более подробно – во второй части курса

Немного ассемблера

+ Мнемоника – текстовое представление инструкции
+ Опкоды – машинно-читаемый код инструкции
+ Инструкции процессора расположены также в RAM – архитектура Фон-Неймана
```c
mov rax, qword ptr [rax]
add rax, 2
mov rbx, 1
add rax, rbx
```
Что такое операционная система?
ОС - это абстракция, которая связывает различные компоненты компьютера и
пользовательские программы.
Зачем она нужна?
* абстракция периферии
* работа с несколькими процессами
* управление памятью

Системные вызовы
+ Системные вызовы – это интерфейс операционной системы для процессов
+ ABI = application binary interface
+ System V ABI

**POSIX**
+ Portable Operating System Interface
+ Стандарт, описывающий интерфейс операционных систем
+ Системные вызовы – часть POSIX, но не всё
+ Например, POSIX описывает как должна быть устроена файловая система

**libc**
Стандартная библиотека C
Реализует системные вызовы в виде
функций C
Ещё куча всяких полезных функций
:)
Много реализаций, glibc одна из самых больших

unistd.h ( read , write , ...)
string.h ( memset , strerror , ...)
stdio.h ( printf , scanf , ...)
fcntl.h ( open , O_RDONLY , ...)

Пример системного вызова: `read`
```C
#include <unistd.h>

ssize_t read(int fd, void* buf, size_t count);
```
Описание
Читает из файла fd в память по адресу buf не более count байт и возвращает
сколько байт было прочитано на самом деле.

Файловые дескрипторы
+ «Everything is a file!»
+ Каждый файл имеет своё имя (или путь)
+ Преобразовывать имя файла на каждый сисколл дорого
+ Сначала нужно получить файловый дескриптор (например, через сисколл
  open )
+ Все остальные операции без использования пути

То есть по сути, вместо `fd` мы ставим файловый дескриптор, кладём указатель на `buf` (буфер).

Теперь полный код:

```C
int main() {
  int fd = open("a.txt", O_RDONLY);  // откроем файл с помощью open, получим дескриптор
  if (fd < 0) {
  // Обработка ошибки, то есть файловый дескриптор меньше 0
    char* err = strerror(errno); // вывод ошибки
// ...
    return 1; // возвращаем 1 = ошибка, должно быть 0
  }
  char* buf = malloc(1025);  // аллоцируем 1025 байт
  if (buf == NULL) {  // если не получилось саллоцировать
  // ...
  }
  ssize_t res = read(fd, buf, 1024); // читаем в буфер, если res < 0
  if (res < 0) {
  // ... 
  }

  buf[res] = '\0'; // нулевой символ
  printf("Read %ld byte(s) from file:\n%s", res, buf);
  return 0;
}
```

**errno**
**errno** – глобальная* переменная, которая хранит самую последнюю ошибку
`errno.h`
`EACCESS`, `ENOENT`, `EINVAL` , `EBADF`, etc
`errno` – не часть ОС, а часть libc