erase x - удалить из кучи x
1) по указателю
сделаем ключ -inf, потом его поднимем сифт апом и сделаем экстракт асимптотика $O(lgn)$
2) по значению
Две кучи A - добавленные элементы, D - удалённые

Тогда добавим в D-кучу элемент x

При обработке запроса getMin и extractMin, мы будем удалять минимальные элементы из А и из D, пока минимумы равны.

В чём идея: мы добавили удаляемый элемент в А, потом мы его удаляем, но мы хотим удалить его и оттуда, и оттуда.

То есть мы добавляем как бы удалённые в D, а само D тоже куча.
Поэтому пока мы удаляем элементы равные в А, и в D мы удаляем "фальшивые элементы" (они были и в А, и в D, то есть удалённые)

А когда мы нашли элемент в А, которого нет в D (корневой в D больше, чем корневой в А), то это и будет истинным (неудалённым) минимумом.

Умеет делать как и [[Простые сортировки|бинарная]], но ещё и Merge

Опр. Биномиальное дерево ранга k (Tk)
$T_0$ - вершина

$T_1$ - вершина с одним сыном

$T_2$ - вершина с одним внуком и 2 сыновьями

В общем виде $T_{k+1}$ ранг - это дерево ранга $T_k$, где одним из его сыновьей подвешивается дерево ранга $T_k$ (берём 2 дерева, соединяем их ребром)
Далее работает требованию кучи (либо min, либо max)

Биномиальная куча - это набор различных биномиальных деревьев **ПОПАРНО РАЗЛИЧНЫХ РАНГОВ**

Как храним в памяти?

Храним деревья, корни связываем двусвязным или односвязным списком.

В дереве $T_k$ число вершин $2^k$

Если всего в куче - $n$ элементов, то всего деревьев не больше $O(lg n)$ (по сути, максимум деревьев у нас типа 1 + 2 + 4 + ...)

Глубина $T_k$ - k (по индукции)

Операции:
1) Merge

Если нет двух одинаковых рангов, то просто скидываем в один список

Если же есть, то просто по определению дерева ранга $T_{k+1}$ можно слить их в одно дерево ранга k + 1

Тогда че делаем, идём 2 указателями по двум кучам:

Если одно меньше другого и его нет в новой куче, то скидываем в новую, если равенство, сливаем в новое

Суммарное время $O(lg n)$, поскольку 2 прохода по lg n массивам.

2) Insert

Создаём новое дерево $T_0$ и делаем Merge.

3) DecreaseKey
уменьшаем ключ + делаем siftUp (всё по классике)

O(lg n) - проверяем все минимумы, можно написать за O(1), если поддерживать указатель на минимум.
Когда происходит мердж - просто знаем где минимум

4) extractMin
Удаляем минимум, поэтому оставшиеся деревья засовываем в одно биномиальное дерево и мерджим.
Почему это работает, потому что все поддеревья корректные биномиальные деревья (дерево $T_k$ за него подвешено $T_0$, $T_1$, $T_2$..., $T_{n - 1}$ по индукции), поэтому при удалении корня мы просто делаем merge с этими деревьями, тогда это всё делается за O(lg n)