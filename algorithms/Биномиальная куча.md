erase x - удалить из кучи x
1) по указателю
сделаем ключ -inf, потом его поднимем сифт апом и сделаем экстракт асимптотика $O(lgn)$
2) по значению
Две кучи A - добавленные элементы, D - удалённые

Тогда добавим в D-кучу элемент x

При обработке запроса getMin и extractMin, мы будем удалять минимальные элементы из А и из D, пока минимумы равны.

В чём идея: мы добавили удаляемый элемент в А, потом мы его удаляем, но мы хотим удалить его и оттуда, и оттуда.

То есть мы добавляем как бы удалённые в D, а само D тоже куча.
Поэтому пока мы удаляем элементы равные в А, и в D мы удаляем "фальшивые элементы" (они были и в А, и в D, то есть удалённые)

А когда мы нашли элемент в А, которого нет в D (корневой в D больше, чем корневой в А), то это и будет истинным (неудалённым) минимумом.

Умеет делать как и [[Простые сортировки|бинарная]], но ещё и Merge

Опр. Биномиальное дерево ранга k (Tk)
$T_0$ - вершина

$T_1$ - вершина с одним сыном

$T_2$ - вершина с одним внуком и 2 сыновьями

В общем виде $T_{k+1}$ ранг - это дерево ранга $T_k$, где одним из его сыновьей подвешивается дерево ранга $T_k$ (берём 2 дерева, соединяем их ребром)
Далее работает требованию кучи (либо min, либо max)

Биномиальная куча - это набор различных биномиальных деревьев **ПОПАРНО РАЗЛИЧНЫХ РАНГОВ**

Как храним в памяти?

Храним деревья, корни связываем двусвязным или односвязным списком.

В дереве $T_k$ число вершин $2^k$ (по индукции)

Если всего в куче - $n$ элементов, то всего деревьев не больше $O(\lg n)$ (по сути, максимум деревьев у нас типа 1 + 2 + 4 + ...)

Глубина $T_k$ - k (по индукции)

Операции:
1) Merge

Если нет двух одинаковых рангов, то просто скидываем в один список

Если же есть 2 дерева $T_{k}$, то просто по определению дерева ранга $T_{k+1}$ можно слить их в одно дерево ранга k + 1. Только подвесить нужно так, чтоб не нарушить требования кучи.

Пусть у нас кучи хранятся в порядке возрастания рангов.
Тогда че делаем, идём 2 указателями по двум кучам:

Если одно меньше другого и его нет в новой куче, то скидываем в новую, если равенство, сливаем в новое

Суммарное время $O(lg n)$, поскольку 2 прохода по lg n массивам.

2) Insert

Создаём новое дерево $T_0$ и делаем Merge.

3) DecreaseKey
уменьшаем ключ + делаем siftUp (всё по классике)

4) getMin
O(lg n) - проверяем все минимумы, можно написать за O(1), если поддерживать указатель на минимум. Делать это надо аккуратно, потому что например при extractMin нам нужно обновлять указатель
Когда происходит мердж - просто знаем где минимум

5) extractMin
Удаляем минимум, поэтому оставшиеся деревья засовываем в одно биномиальное дерево и мерджим с нашим исходным нам тут понадобится следующий факт:


**Лемма**. Биномиальное дерево $T_{k}$ - это вершина + подвешенные за неё деревья $T_{0}, T_{1}, ...,T_{k-1}$
Доказывается по индукции

Ну и поскольку мы потом запускаем мердж, то можем найти новый минимум.