Основная операция дерева splay(x) - подъём узла x в корень дерева.
Операции:
1) Zig - если отец x - корень (x - левый ребёнок), то есть мы делаем правое вращение
2) Zig-Zag - у x есть дед и они направлены в разные стороны (типа p - правый ребёнок g, а x - левый ребёнок p). Тогда мы сделаем поворот x, p, а потом g, x
3) Zig-Zig - если в одну сторону, если x - левый ребёнок p, p - левый ребёнок g. Тогда мы делаем сначала поворот p, g, а потом поворот x, p 
Ну и делаем подряд просто операции, пока не подымем х в корень, тогда если мы хотим добавить элемент, мы его вставляем и делаем сплей
Идея в чём, если мы делаем инсерт, то мы идём вниз, а потом поднимаемся вверх (сплей), то есть все операции зависят от сплея, тогда нам остаётся только что сплей за лог работают
Как докажем?
Возьмём все элементы, возьмём для каждого элемента размер поддерева х s(x), тогда rank(x) = log2 s(x)
Тогда потенциал = сумма по всем рангам
Чтоб посчитать время сплея, посчитаем для каждой операции, докажем, что
для 1: <= 1 + 3(r'(x) - r(x)), для 2, 3 <= 3(r'(x) - r(x))
для 1) аморт = время (1 поворот) + изменение рангов, 2) - 2 поворота + изменение рангов тут у нас сокращаются r'(x) и r(g) и -r(p) <= -r(x), ну и далее по сути заметим, что если размер поддерева p = a, размер поддерева g = b, тогда размер поддерева x = a + b + 1 (ну скажем a + b), тогда
log a + log b - 2log(a + b) <= -2 - а это верно по неравенству о средних. в 3) аналогично, только тут мы ещё добавляем, что r'(p) <= r'(x)
Merge - возьмём самый большой элемент маленького дерева (где все элементы меньше чем в большом), сделаем сплей, тогда у нас справа будет висеть большое дерево, а слева - маленькое