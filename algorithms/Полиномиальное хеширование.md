Строкой будем называть какую-то последовательность элементов $s_{1}, ..., s_{n-1}$

Из какого-то множества (ну как [[Слова и языки|тут]]).

В целом, идея проста - можно вместо строки работать с каким-то числом, которое мы назовём хэшем.

И как-то оперировать со всем этим, чтоб было просто.

Самое простое хэширование - полиномиальное, введём его:
$$
h(S) = (s_{0}p^{n-1} + s_{1}p^{n-2} + ... + s_{n-1}) \mod m
$$
Ну $s_{i}$ - либо код в ASCII таблице, либо порядковый номер в алфавите. И в целом, мы не хотим, чтоб какой-то хэш был нулевым (например, `a` ), потому что тогда и все строки с $a$ тоже имеют нулевой хэш, что в целом лишено смысла.

Теперь решим задачу. О вхождении шаблона в текст. Пусть есть строка $p$ и шаблон $t$, нужно найти все вхождения строки $p$ в шаблон $t$.

Решение простое - возьмём строку $p$ и посчитаем подстроки $t$. Если $h(p) == h(t)$, то мы получаем вхождение.

Почему мы считаем, что коллизий - мало.

Если $m$ достаточно больше число, то вероятность попасть в корень пропорционально $\frac{n}{m}$, где $n$ - степень.

Ну и префиксы мы можем посчитать просто динамически: домножая на нужное число.

Как найти хэш подстроки:

$$
(pref_{r} - pref_{l-1} * b^{r-l + 1}) \mod m
$$
Идейно всё просто - мы просто подгоняем подстроку к определённой степени