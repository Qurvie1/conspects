Дан невзвешенный [[Граф|граф]], нужно найти кратчайшее расстояние для всех $v \in V$

В чём сам алгоритм **BFS - breadth first search** (поиск в ширину).

Будем из одной вершины $s$ (у неё расстояние 0), возьмём все рёбра из неё и запишем этим вершинам расстояние 1, тогда всем вершинам из этих вершин опять обновим расстояние.

Введём функцию $Expand$ (это как раз для вершины $v$ мы обновим пути до всех вершин, соединённых ребром с $v$):

```cpp
void Expand(int v) {
	for (auto& edge : g[v]) {
		dist[edge.to] = std::min(dist[edge.to], dist[v] + 1);
	}
}
```

Заведём массив расстояний с $+inf$.

Заведём очередь вершин (чтоб обрабатывать сначала на расстоянии 1, потом 2 и так далее).

Докажем корректность.

1) BFS рассматривает вершины в порядке неубывания $dist$.
2) После рассмотрения последней вершины с $d[] = k$, тогда если $dist(s, u) \leq k + 1$, то $d[u]$ найдено корректно. В очереди лежат в точности все вершины с $dist(s, u) = k + 1$

1 пункт очевиден +-, потому что если у нас лежат вершины с дистанцией $d$ и $d + 1$, то после обработки вершины с $d$, у нас добавляются вершины с $d + 1$ (увеличивающимся).

Докажем (индукция по $k$).

База $k = 0$ - очевидна.

Переход - то есть у нас установлено корректное значение пути для вершин с расстоянием $\leq k + 1$ и в очереди лежат вершины в точности с $k + 1$. Тогда после раскрытия всех этих вершин в очереди мы точно найдём все вершины на расстоянии $k + 2$, с другой стороны - ничего лишнего мы не добавим. При этом мы найдём все, потому что у нас точно в очереди лежат все на $k + 1$.

Обобщение - $0-k$ BFS.

Способ 1 - просто разбиваем ребро веса $w > 1$ на кучу рёбер с фиктивными вершинами.

Способ 2
Для каждого $x$ заведём очередь $q[x]$ куда будем складывать вершины с найденным расстоянием (ровно $x$).

Каждая вершина может побывать во многих очередях (в очереди длины 2, 3 и так далее). Поэтому введём массив $expand$ - который будет отмечать.

Причём каждая вершина не может быть более чем в $k$ очередях.
Почему? Пусть мы раскрываем ребро $(u, v)$, причём $u$ находится на расстоянии $L$, но тогда $v$ попадёт в очередь $w + L$. Мы не можем раскрывать на пути меньшем $L$, так как это $BFS$ и он корректен.

```cpp
void Expand(int v) {
	if (expanded[v]) {
		return;
	}
	expanded[v] = true;
	for (auto& edge : g[v]) {
		x = d[v] + edge.w;
		if (d[edge.to] > x) {
			d[edge.to] = x;
			q[x].push(edge.to);
		}
	}
}
```

Сам алгоритм - просто `for(x = 0 ... nk)` - раскрываем уровень.

**Утверждение**. После рассмотрения $x$-й очереди все вершины с $dist(s, v) \leq x$ раскрыты и до них найдено корректное расстояние.

Доказательство:

Индукция по $x$.

База $x = 0$. Достаточно очевидно, что по рёбрам нулевого веса мы найдём все вершины на расстоянии 0 и раскроем их.

Переход $x - 1 \rightarrow x$

Для $x - 1$ мы всё знаем, нам нужно доказать, что все вершины на расстоянии $x$ будут просмотрены в этой очереди и раскроются. 

Пусть $v$ - какая-то вершина на расстоянии $dist(s, v) = x$. Рассмотрим предпоследнюю вершину на этом пути - $u$ такую, что её расстояние меньше чем $x$. По предположении индукции $u$ раскрыта и до неё найдено правильное расстояние. Ну и тогда мы тоже добавили вершину на этом пути на расстоянии уже $x$ (так как мы прорелаксировали все рёбра из $u$, то там точно было ребро, которое лежит на кратчайшем пути, поэтому мы добавили эту вершину в очередь).

Тогда и все рёбра нулевого веса мы тоже пройдём и в конечном итоге добавим в очередь вершину $v$.

Асимптотика очевидно $O(kV + E)$, память $O(kV + E)$

Если заметить, что в каждый момент времени у нас задействуется $k + 1$ очередей (не более чем), то можно сэкономить на памяти и добавлять вершины $dist[v]$ по модулю $k + 1$.

Тогда память будет $O(k + E)$

Двусторонний $BFS$. Расстояние между двумя конкретными вершинами.

Можно запустить $BFS$ с двумя вершинами и тогда $dist(s, t) = \min_{m}(d_{s}[m] + d_{f}[m])$

Заканчиваем обход, когда будет найдена вершина $v$, для которой мы определили $d_{s}[v]$ и $d_{f}[v]$, и при этом целиком просмотрены оба слоя.

Особенно полезны в случае поиска на плоскости, потому что делаем сильно меньше действий.