Задача - смерджить 2 отсорченных куска за $O(1)$ доп. памяти.

Доп.задача - циклический сдвиг на k.
Решение: по сути, мы просто можем посвопать, первый - с n - k
И так далее, но мы вычисляем gcd(n, k) (чтоб не зациклиться раньше).

Доп.задача 2 - реверс массива (по сути аналогичная задача, если мы берём k и n - k)

Что мы обычно делаем в Merge - мы можем взять O(меньшего массива)
В чём идея: возьмём для $k$ первые $k$ максимумов в двух массивах (суммарно, то есть $k_1$ в первом и $k_2$ во втором)
Тогда в целом у нас есть буфер обмена максимумов и если взять $k = \sqrt{n}$.
Пусть первый подмассив останется маленьким:
$$2, 6, 10, 14, 21, 46 | 3, 10, 15, 20 | 57, 179, 2007, 239, 444$$
Теперь 2 указателя на старт, 46 > 20, поэтому свапаем с 444
$$2, 6, 10, 14, 21, 46| 3, 10, 15, 444 | 57, 179, 2007, 239, 20$$
21 > 20 поэтому теперь аналогично

$$2, 6, 10, 14, 239, 444 | 3, 10, 15, 20 | 57, 179, 2007, 21, 46$$
Теперь 20 > 14, поэтому теперь уже своп со вторым
$$2, 6, 10, 57, 239, 444 | 3, 10, 179, 2007 | 14, 15, 20, 21, 46$$
и так далее, заполняем буфер, теперь уже 10 свапается с 2007:
$$2, 6, 1007, 57, 239, 444 | 3, 10, 179, 10 | 14, 15, 20, 21, 46$$
То есть мы сравниваем каждый раз 2 элемента и пишем подряд.
В чём идея - поскольку мы берём максимумы, то мы вполне сначала пишем на них

Потом мы просто можем перекинуть в конец максимумы (циклический сдвиг) и отсортить [[Простые сортировки|вставками]] за квадрат, поэтому будет $O(n)$

Глобально, в чём смысл того, что первый подмассив маленький (меньше буфера) - нам это позволяет реализовать по сути обычный мерджсорт (то есть обменивая максимумы и элементы поменьше мы никогда не пересечём указатели).
То есть теперь мы умеем сливать такие массивы

Возьмём число BUBEN = $\sqrt{n}$, округлённое вниз.

Тогда количество максимумов будет k = $[Buben, 2 * Buben)$, так, чтоб $buben | n - k$
Поделим блоки по Buben элементов

Выкинем Buben на пересечении (в начало), посортим и потом можно слить (если мы берём большой массив слитый по куче бубнов + этот бубен в начале - мы умеем сливать такого вида подмассивы), ничего толком не меняется, поэтому можно считать, что этой погран. заставы нет.

Посортируем по максимальным элементам (последнему) сортировкой выбором (это важно, чтоб не было большого числа обменов, потому что тогда очень тяжело двигать) или по минимальному, если максимальные равны

Вот в чём идея - далее идём и набираем пока массив отсорчен

Пусть мы взяли t блоков, t + 1 блок портит
Тогда сольём их в 1, используя буфер, тогда на первых t блоках будут стоять те элементы, которые должны стоять на этих местах, тогда на них можно тупо забить.

Почему это так?
Относительные порядки 1 и 2 массива не поменяются, тогда получаем, что если у нас t + 1 нарушил порядок, то он из синего, а до этого был блок из красного.
И в чём идея то, каждый следующий блок из оставшегося массива либо красный, либо синий, поэтому он больше либо равен минимума из красного и синего.

Но тогда максимальный из элементов в t блоках (меньшие его либо левее, либо некоторые из t + 1)

Суммарно за O(n)
