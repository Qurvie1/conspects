Идея: часто массивы почти отсортированы и хочется чтоб в идеале она работала за O(n)

1 шаг:

В чём идея: вычислим некоторое число minRun, разобъём массив на Run-ы (отсортированные массивы), будем их сливать

minRun - некоторая константа от 32 до 65
**Делаем run-ы**:
Ищем максимально отсортированный массив, разворачиваем (если отсортирован по убыванию) + дополняем до minRun элементов (если нужно) (это сборка run-массива)

**Cортируем run [[Простые сортировки|вставками]]** (очевидно, что только ту часть, которая не отсорчена)

Если слишком много отсорченных элементов, то останавливаем поиск run-а, обрываем (типа чтоб слишком много не брать).

2 шаг:
Теперь слияние run-ов.
Используем стек Run-ов (убывающих по длине).
Рассмотрим какие-то подряд идущие Run-ы
Z, Y, X (по длине снизу типа), то должен выполняться следующий инвариант:
1) |Y| > |Z|
2) |X| > |Y| + |Z|
Как мы это добиваемся: мы сливаем какие-то Run-ы между собой, чтоб выполнялся этот инвариант

Неасимптотические оптимизации:
minRun (32 - 64) элемента

Есть 2 массива, которые стоят рядом и копировать можно только левый, то есть в чём идея:
они располагаются друг за другом, поэтому если элемент в первом массиве меньше, чем во втором, то всё окей, если наоборот, то просто перекидываем в первый массив.
Тогда мы улучшаем асимптотику до O(меньшего массива).
то есть левый массив кидаем в буфер, потом уже как-то сортим.

Если у нас какое-то элементов подряд берётся из одного и того и того же массива (7), то находим итоговое количество бинпоиском, то есть находим сколько ещё элементов нам нужно отсюда, тогда можно копировать "скопом" типа memcpy

**Адаптивный бинпоиск**: пусть у нас есть подсказка, что элемент находится на суффиксе > pos
Тогда посмотрим не на pos ли x, не на pos + 1 ли x, не на pos + 2 ли x и так далее, пока 
$pos + 2^k < x$, а уже $pos + 2^{k+1} > x$ тогда как раз на этом подмассиве мы и ищем x.
Тогда асимптотика это $k = \Theta(lg (ans - pos))$

Ну и тогда можно предположить, сколько элементов будут из одного массива и сделать адаптивный бинпоиск.

3 шаг: слияние
Высота стека - логарифм, потому что из инварианта получаем, что |Z| < $\frac{|X|}{2}$ - то есть если снизу стека лежит размер k, то суммарно у нас там лежит $lg k$ элементов.
Тогда в чём идея, у нас сверху вниз сливается, но $x_i$ участвует в слияниях $i$ раз
Можно разбить на нечётные и чётные, но тогда одно выполняется за $\Theta(x_1)$, а другое за $\Theta(x_2)$
То есть суммарно за линию идёт слияние.

В чём идея
Если для какой-то тройки ломается инвариант, то средний элемент Y, то сливаем с наименьшим (с X или Z). Далее проверяем инвариантность с нижней тройкой
Для доказательства асимптотики стоит класть на каждый ранг монетки
