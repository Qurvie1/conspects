Пусть каждая вершина (вершина - узел) дерева снабжена v.key, тогда для дерева поиска выполнено
[[Узел]]

для любой вершины х, в левом поддереве вершины х, для любой y выполнено:
y.key <= x.key
в правом:
y.key >= x.key
Другое определение: если inOrder обход выдаёт ключи в порядке неубывания
Интересно, что количество деревьев поиска на n вершинах == количество правильных скобочных последовательностей. Можно установить биекцию: если идём из вершины направо, то для двух вершин ()()
если из вершины налево (())
Поиск и вставка:
поиск максимально очевиден, стартуем с корня, дальше смотрим: если значение больше чем нынешний ключ, то идём направо, иначе налево, вставка так же, просто мы вешаем новый элемент
Аssимптотика: O(h)
Аналогично можно найти макс\мин, если будем идти вправо, влево
Удаление:
если лист, то просто удаляем, если есть правый или левый ребёнок (только), то заменяем вершину на ребёнка, далее, если 2 ребёнка:
делаем следующую штуку: мы берём и ищем самый МАЛЕНЬКИЙ элемент в ПРАВОМ ПОДДЕРЕВЕ и заменяем на его, в чём идея: всё правое поддерево так же больше или равно наименьшего
При этом любой элемент из правого поддерева больше или равен любому из левого.
В чём проблема: высота дерева может быть n, тогда переходим к [[АВЛ-дерево]]
