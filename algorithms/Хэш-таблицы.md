Хотим понимать, есть ли какой-то конкретный элемент в массиве.

Как можно сделать вставку, удаление и проверку за 1.

Как можно их хранить?

Допустим, нужно хранить числа от $0$ до $m - 1$. Как можно это всё разместить?

Ну просто храним буль в массиве размера $m$ - есть ли элемент или нет.

Ячейки массива назовём корзинами - **bucket**.

Хотим определить функцию - отображения в числа, чтоб понять куда положить тот или иной элемент. То есть мы набору ключей сопоставляем число и можно работать как выше - типа false или true хранить, но уже по хэшу.

Но если количество ключей много больше, чем $m$, то нельзя по сути чтоб кодировали разные числа.

Получаются **коллизии** (то есть когда одному и тому же хэшу соответствуют разные ключи).

**Метод цепочек** - храним в ячейке массива не элемент, а список и запихиваем в этот список элементы новые.

Время работы `Erase`, `Insert` и `Find` совпадают

А чему равно время? $Find(x) = O(1 + L(x))$.

Всё упирается в хэш.

**Просто равномерное хэширование**.

Если $x$ - новый ключ, то $h(x) = random(m)$, иначе берём старый $h(x)$.

$n$ - число элементов, $m$ - размер хэш-таблицы.

Тогда средняя длина цепочки

$$
EL(x) = E \sum\limits I(h(x) = h(x_{i})) = \sum\limits P(h(x) = h(x_{i})) = \sum\limits \begin{cases}
1, x = x_{i} \\
\frac{1}{m}, x \ne x_{i}
\end{cases} \leq 1 + \frac{n}{m}
$$

Поэтому если поддерживать $\frac{n}{m} \leq 1$, то мы получаем константу.

Как делать $Find$ и $Erase$ понятно, если же нам нужно делать $Insert$, то мы также вставляем в корзину, иначе делаем $Rehash$, генерируя новые хэш-функции.

Проблема - а существует ли ПРХ?

Множество из $n$ элементов можно представить с помощью $\lg n$ бит

Количество хэш функций $m^{|K|}$

Тогда нужно: $|K|\lg m$ бит, что даже для интов очень много.
