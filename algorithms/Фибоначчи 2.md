Всё за О(1), но удаление за логарифм.
(decreaseKey за амортизированную единицу, удаление за амортизированный логарифм).

Куча - набор деревьев, корни деревьев в двусвязном списке.

**Ранг вершины** - количество её детей.

В каждой вершине будем хранить количество её детей. Что нужно знать для вершины?

Указатель на родителя

Детей вершины будем хранить как двусвязный список с указателями на самого левого и самого правого сына.

Ранг вершины

Булевский флаг - mark - правда ли, что у вершины высекался один из сыновей

Тогда как делать `insert`? Просто присоединяем вершину в списке.

`getMin` - просто храним указатель на минимальный корень, находим ответ, следим за ним при действиях.

`merge` - просто закидываем в один список обе кучи, обновляем минимум

`extractMin` - берём минимум и его детей. Так как у нас дети образуют двусвязный список, то объявляем его новой кучей.
Этот минимум удаляем и в старой куче обновляем указатели (так как удалили корень в двусвязном списке)
А потом запускаем `merge` с новой кучей.
Вроде бы это работает за единицу, но теперь мы начинаем причёсывать кучу, чтоб найти новый минимум, дабы `getMin` работал за 1 (то есть нам нужно пробежаться по корням).

Тут мы запускаем новую операцию - `consolidate` - причёсывание кучи и поиск минимума заново.
Будем делать по сути то же, что и `merge` в [[Биномиальная куча|биномиальной]].

Пусть $D(n)$ - максимально возможный ранг в куче на $n$ элементах. Тогда заведём массив от 0 до $D(n)$.

Пример:

Куча с деревьями рангов - 0, 1, 0, 3, 1, 2

Берём дерево ранга 0, его ещё не добавляли в массив, добавляем, потом дерево ранга 1 тоже добавляем.

Дерево ранга 0 уже было, тогда сравниваем у кого значение в корне меньше и подвешиваем одну кучу в другую (чтоб сохранилось условие кучи), тогда у нас становится 1 дерево ранга 1.
Аналогично с деревом ранга 1. Ну и аналогично с другими

Итого получим дерево ранга 1 и 4.

Время работы - количество корней + $D(n)$. А ещё мы прошлись по всем корням, то есть можем найти минимум.

Переходим к `decreaseKey`.

У корней деревьев mark всегда false.

Далее выставляем `mark` = true, если вершина - не корень и у неё вырезается один из детей.

Тогда как делать `decreaseKey`? Опять же, делается по указателю, в чём идея - мы просто его вырежем и добавим в список корней.

В чём проблема? Если у отца вершины у которой делали `decreaseKey` уже `mark == true`, то мы не можем так делать, тогда отца нужно добавить в список корней.

А если у отца отца тоже `mark == true`, то тоже надо выносить.

Проведём теперь анализ асимптотики

Пусть на каждом корне лежит по монетке, а на каждой вершине с `mark == true` лежит по 2 монетки.

В чём идея - во время выполнения `consolidate` мы берём 2 дерева с 2 монетками, объединяем их и оплачиваем 1 монеткой и оставляем вторую монетку на объединённом дереве.

Тогда учётное время `consolidate` - $O(D(n))$

`insert` - добавили новое дерево и добавили монету на новый корень. (константа)

`getMin` - просто возвращаем число

`merge` - тоже легко

`decreaseKey` - вырезаем дерево на которое делается decrease - 3 действия (вырезать, вставить в список, потратить 1 монетку, потому что штука в корне).

Далее, пока мы идём по родителям с `mark == true`, то у нас там лежит по 2 монетки - за одну монетку мы вырезаем + кладём их в список, а одну монетку оставляем.

В итоге мы совершаем действия только с вершиной на которую делается `decrease` и на последнего родителя, у которого `mark == false` мы кладём 2 монетки, так как вырезаем сына и делаем `mark == true`, итого 5 действий.

Тогда учётное время = время + сколько монеток положили - сколько сняли, то есть получается единица.

Теперь осталось понять - что такое $D(n)$. Обратим задачу - по рангу найдём минимальное число вершин.

Пусть $S(k)$ - минимальное число вершин в дереве ранга $k$.

Примеры:

$S(0) = 1$ (1 вершина без детей).

$S(1) = 2$ (1 вершина + ребёнок)

Теперь рассмотрим вершину ранга $k$ - у неё $k$ детей ($u_{0}, u_{1}, ..., u_{k-1}$) - пусть дети упорядочены в порядке подвешивания к $v$.

В момент подвешивания вершина $u_{i}$ имела ранг $\geq i$. Почему так? Ну $u_{0}$ понятно, а как мы подвешиваем деревья в `consolidate`? Мы подвешиваем деревья одинакового ранга друг за друга, поэтому после $u_{0}$ мы подвесили дерево ранга $u_{1}$ хотя бы 1 (объединили 2 дерева 1 ранга), потом хотя бы $2$ (объединили 2 дерева ранга 2).

А какой у детей ранг теперь? Не меньше, чем $i - 1$ (помеченные).

Тогда сколько вершин в дереве ранга $k$? сама вершина + $u_{0}$.

А у других вершин ранг хотя бы $0, 1, ..., k - 2$, а в них количество вершин (минимальное) - $S(i)$.

То есть суммарно:
$$
S(k) \geq 2 + \sum\limits_{i=0}^{k-2} S(i)
$$
(а это числа **фибоначчи**).

Тогда $S(2) \geq 2 + S(0) = 3$
$S(3) \geq 2 + S(0) + S(1) = 5$
$S(4) \geq 2 + S(0) + S(1) + S(2) = 8$

По индукции очевидно $S(k) \geq F(k + 1)$
$S(k) \geq S(k - 1) + S(k - 2) = F(k) + F(k - 1) = F(k + 1)$.

А как быстро растут числа фибоначчи? По экспоненте.

Поскольку получили:

$S(k) = \Theta(\phi^{k}) \implies k = \lg S$

То есть
$$
D(n) = O(\log_{\phi}n)
$$



