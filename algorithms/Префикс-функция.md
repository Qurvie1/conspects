Пусть есть строка 
$$s_{0}, ..., s_{n-1}$$
Тогда префикс-функция - это массив:
$$
\pi_{0}, \pi_{1}, ..., \pi_{n-1}
$$
Такая, что $\pi_{i}$ - это длина наибольшего собственного суффикса строки $s_{0}, ..., s_{i}$ совпадающая с префиксом той же строки.

Как решить задачу о вхождении шаблона в текст? Мы уже научились её решать с помощью [[Полиномиальное хеширование|хэшей]], хотим ещё и префикс-функцией.

Введём следующую строку: $s = p + ? + t$

Тогда всюду, где мы имеем вхождение $p$ в текст $t$ там будет $\pi_{i} = |p|$. В целом просто по определению префикс функции.

Собственный суффикс, совпадающий с префиксом назовём **супрефиксом**.

Как посчитать в целом префикс-функцию? Нам нужно в каждой позиции $i$ найти самый длинный супрефикс.

Допустим, мы посчитали $\pi_{0}, ..., \pi_{i-1}$, как найти следующее значение?

Заметим, что по сути, мы можем убрать последний символ и посчитать супрефикс для строки поменьше. Тогда для новой строки мы можем просто проверить удалённый символ со следующим символом префикса.

Тогда переберём все супрефиксы предыдущей строки и проверять - правда ли, что следующий за префиксом символ равен новому, не добавленному символу, если да, то берём это в качестве префикс функции. Ну и берём самый большой такой супрефикс очевидно.

Теперь в целом логичный вопрос - а как перебирать супрефиксы? Возьмём максимальный.

Рассмотрим второй супрефикс по размеру, а где он? А это супрефикс для максимального супрефикса (поскольку у нас для максимального - конец совпадает с началом, тогда для супрефикса поменьше тоже будет конец совпадать с началом, но это всё входит в большой супрефикс и так далее).

Ну а для большого супрефикса мы уже всё посчитали
Напишем псевдокод:
```cpp
std::string s;
int n = s.size();
std::vector<int> p(n, 0);
int j = 0;
for (int i = 1; i < n; ++i) {
  // j = p[n-1]
  // это максимальный, теперь будем его уменьшать, пока он не продляется
  // символом s_i
  while (j > 0 && s[j] != s[i]) {
    j = p[j - 1];
  }
  if (s[i] == s[k]) ++j;  // продлеваем
  p[i] = j;
}
```

Корректность в целом понятна из построения, докажем асимптотику.

Каждая итерация по `while` уменьшает $j$ хотя бы на $1$.

Каждая итерация `for` увеличивает $j$ не больше, чем на 1.

Тогда в целом получаем линейное время работы $O(n)$.
