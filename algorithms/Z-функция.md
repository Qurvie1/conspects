По аналогии с [[Префикс-функция|префикс-функцией]]: есть строка и есть функция

Такая, что:

$z_{i}$ - это максимум по всем $k$ таким, что префикс исходной строки длины $k$, совпадает с подстрокой $[i, i + k - 1]$ (то есть старт с $i$ длиной $k$ совпадает с первыми $k$ символами исходной строки).

Аналогично можно выполнить поиск шаблона в строке, то есть также должно быть $z_{i} = |p|$

Алгоритм нахождения.

Тоже будем идти по строки слева направо и подсчитывать. Пусть посчитано всё до $z_{i-1}$.

Тогда будем хранить $z$-блок. То есть подстрока, равная префиксу длины $k$. Будем хранить координаты $left, right$ самого правого $z$-блока (то есть того, у которого правая граница **максимальна**).

По сути, если у нас $s_{i}$ лежит в $z$-блоке и нам нужно найти значение функции, то поскольку $z$-блок с $[left, right]$ эквивалентен префиксу $[0, right - left]$ (следует просто из определения префикс функции, то есть эта подстрока равна префиксу по определению).

В таком случае, чтоб определить значение $z_{i}$ мы можем просто смотреть аналогичное в префиксе $[0, right - left]$

Но это можно сделать логично только так, чтоб не вылезти за границу этой подстроки, то есть:
$$
i + z_{i-l} < r - l
$$
Тогда $z_{i} = z_{i-l}$. Если выходит за границу, то мы можем сделать максимум правую границу $z$-блока, иначе мы дальше ничего не знаем. Ну а дальше просто прогнаться по массиву и попроверять значение. Ну и сдвигать $z$-блок

Псевдокод:
```cpp
std::string s;
int n = s.size();
std::vector<int> z(n, 0);
int l = -1;
int r = -1;
for (int i = 1; i < n; ++i) {
  if (l <= i && i <= r) {
    z[i] = std::min(z[i - l], r - i + 1);
  }
  while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
    ++z[i];
  }
  if (i + z[i] - 1 > r) {
    l = i;
    r = i + z[i] - 1;
  }
}
```

Асимптотика $O(n)$.

Почему? Посмотрим на $r$, каждая итерация `while` сдвигает $r$ хотя бы на 1. Тогда итераций цикла `while` было $O(n)$.