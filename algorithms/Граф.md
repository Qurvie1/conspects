**Определение.** Ориентированным графом называется $G = (V, E)$ (пара).
$V$ - конечное множество, $E \subset V$ х $V$.

**Определение**. Неориентированный граф - это просто если пары в $E$ неупорядоченные.

Как будем хранить граф в памяти?
+ Список рёбер, то есть просто список пар вершин
  Память - $\Theta(E)$
  Обход всех рёбер - $\Theta(E)$
  Поиск ребра - $O(E)$
  Получение соседей - $\Theta(E)$
+ Сортированный список рёбер (отсортировать по началу и по концу)
  Тяжело вставить/удалить ребро + надо отсортировать
  Память - $\Theta(E)$
  Обход - $\Theta(E)$
  Поиск ребра - $O(\lg E)$
  Получение соседей конкретной вершины - $O(\lg E + \deg_{+}(v))$
+ Матрица смежности - просто массив $V$ х $V$, где в пересечении стоит либо буль - есть или нет ребра, либо количество рёбер, либо вес ребра
  Неэффективна для разреженных графов
  Память - $\Theta(V^{2})$
  Обход всех рёбер - $\Theta(V^{2})$
  Поиск ребра в графе  - $O(1)$ 
  Получение соседей вершины - $\Theta(V)$
+ Список смежности
  Память - $\Theta(V + E)$
  Обход всех рёбер - $\Theta(V + E)$
  Поиск ребра - $O(\deg_{+}(v))$
  Получение соседей вершины - $O(1)$

Алгоритм $DFS$ (depth-first search).
Хочет обойти весь граф, при запуске из вершины рассматривает все возможные рёбра, выбирает то, которое ведёт в первую непосещённую вершину.

Пусть граф хранится в векторе векторов (список смежности). Далее у нас есть 4 массива - $tin$, $tout$, $parent$ и $color$.

Изначально все вершины покрашены в белый цвет, в момент захода в вершину будем красить её в чёрный цвет.

**Лемма.** (о белых путях)
Пусть $G$ - неориентированный граф. Для любой вершины $v$ за время от $tin[v]$ до $tout[v]$ алгоритм посетит все вершины, достижимые по белым путям из $v$.

Доказательство.
Мы точно не могли посетить недостижимые из $v$ вершины, с другой стороны, мы не посетим серые или чёрные вершины.
Пусть нашёлся какой-то путь по белым вершинам, на котором не все вершины покрасились в чёрный.
Заметим, что в любой момент времени серые вершины образуют путь и лежат на стеке рекурсии (вершина $v$ делается серой, потом идём в вершину $u$, она тоже становится серой и так далее).
То есть на этом пути могут быть только белые и чёрные вершины.
Тогда рассмотрим самую высокую белую вершину, её родитель очевидно чёрный. Но тогда чёт странное случилось, потому что 

Следствие 1. Если изначально все вершины белые, то $dfs(s)$ пометит чёрными все достижимые из $s$ вершины.

Следствие 2. $dfs(s)$ находит ребро в серую вершину $\iff$ в $G$ есть цикл, достижимый из $s$.

Доказательство. $\implies$ очевидно, потому что серые вершины образуют путь и есть мы нашли ребро в серую, то мы замкнулись, то есть образовали цикл.
В другую сторону, найдём вершину $u$ с минимальным $tin$ в цикле, тогда по лемме о белых путях мы точно запустимся от предпоследней вершины $v$ и точно находим ребро $vu$, ведущее в серую вершину.

$DFS$ образует дерево обхода, если смотреть на только посещённые рёбра
1. Ребро дерева - ребро, ĸоторое принадлежит ĸаĸому-то дереву обхода. (в белую вершину)
2. Обратное ребро - ребро, ведущее из потомĸа в предĸа в неĸотором дереве. (в серую вершину)
3. Прямое ребро - ребро, ведущее из предĸа в потомĸа, не являющегося сыном. (в чёрную, но $tin[v] < tin[u]$)
4. Переĸрестное ребро - ребро, соединяющее вершины не связанные отношением "предоĸ-потомоĸ" (все остальные ребра, то есть в чёрную вершину $tin[v] > tin[u]$).