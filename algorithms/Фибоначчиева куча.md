Всё за О(1), но удаление за логарифм.
(decreaseKey за амортизированную единицу, удаление за амортизированный логарифм).

Сначала храним всё в двусвязном списке с указателем на минимум, всё хорошо
но как же делать extractMin
5 <-> 7 <-> 2 <-> 4 <-> 8 <-> 5
допустим, хотим удалить 2
сделаем тупо [[Биномиальная куча|биномиальную кучу]] из левого куска и правого

В чём инвариант - у нас куча состоит из списка корректных биномиальных деревьев
extractMin вызывает мистическую функцию consolidate.

в каждой вершине будет храниться ранг

Ранги не больше логарифма, поэтому заведём вектор на log и будем хранить дерево соответствующего ранга, перебираем все деревья, вносим, в это время мерджа всё подряд, чтоб не было пересечений

Возьмём потенциал - количество деревьев в головном списке (в куче) $t(H)$ 

Тогда учётное время: было (t деревьев), стало (log), реальное - t (потому что проходимся по всем деревьям), то есть амортизированно за log.

В случае экстракт мина мы просто возьмём все деревья от этой вершины (биномиальные), перетащим их в список и просто сделаем consolidate (сольём).

Причём само слияние в консолидейте считаем бесплатным (оплаченным за счёт других) 
Как erase? Просто на -бесконечности и выводим в корень

Но есть ещё операция decreaseKey.
Во всех нормальных кучах это происходит за log, но куча фибоначчи это делает за О(1).

Что мы сделаем - просто возьмём и вынесем ребёнка и поддерево в список, а родителя - пометим. Теперь, если мы будем вырезать ещё одного ребёнка у меченого родителя, то мы будем (и родителя) выносить в корень (это каскадинг кат)

Теперь возьмём потенциал получше - t(H) + 2m(H), где m - число меченых вершин.
Почему? Пусть выпиливаем вершину и метки нет, тогда мы её ставим (потенциал увеличивается на 3). Ну и так далее - всё супер.

Теперь появляется новая проблема - у нас не биномиальные деревья и вся проблема появляется в consolidate, потому что теперь уже нам никто не обещает, что количество деревьев будет $O(lgn)$

Пусть D(n) - максимальный ранг, который может получиться, тогда у нас время теперь D(n).
Вообще, у нас нет понятия ранг, но есть понятие количество детей у вершины - этим мы и будем пользоваться.

Рангом будем считать количество детей + орден (метка), у корней орденов нет.
Пусть $min_{sz} >= 1 + minsz(0)...$ - минимальное количество вершин в поддереве вершины ранга r.

Как вообще устроено дерево ранга r - либо r детей (если корневой), либо r - 1, если не корневой, а какие ранги у детей?

Дерево ранга 1 - появился ребёнок ранга 0, либо поддерево отпилили.
Ранг 2 - повесили 1 и 0
Ранг 3 - 

Лемма. Рассмотрим вершину, отсортируем детей по рангам. Тогда ранг $rg_i >= i - 1$
Индукция по количеству действий в куче.
1) По создании всё окей
2) Как может поменяться список детей? Когда 2 вершины одинакового ранга меняются

Ремарка: пока вершина в корней - её ранг - количество детей, как только она перестаёт быть корнем, то ранг фиксируется, пока она не вернётся в корневой список.

Когда отпиливают, то инвариант не меняются, если припиливают, то точно вершину ранга k, но тогда инвариант верен с точностью до просвапывания 
Теорема. minsz(r) >= $Fib_r$
