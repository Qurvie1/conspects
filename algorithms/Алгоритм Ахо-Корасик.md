Задача. Назовём слова $s_{1}, ..., s_{n}$ - словарём.
Есть какой-то текст $t$. И наша задача найти вхождение всех слов из словаря в текст $t$.

Ну по сути то же самое, что дефолтная задача [[Префикс-функция|как тут]].

Но теперь это уже неэффективно.
А что делать то?

Вторая задача тут же - вывести все вхождения.

Построим [[Бор|бор]] на наших всех словах. Слово есть в боре, если его можно прочитать из корня.

Вершина бора соответствует некоторому подслову, если пройти по символам.

Введём определение `link[v]` - максимальный собственный суффикс строки $v$, который есть в боре. 

Ну например, для слова `abacaba` у нас есть ссылка в `aba`.

Далее, нам нужно `go[v][c]` - максимальный суффикс строки $v + c$, который есть в боре ($v$ - строка, $c$ - символ).

Например, для слова `abacaba`, пусть у нас в боре есть слово `cabc`, если мы допишем в конец на букве `b` символ `c`, то будет `abacabc`, тогда наибольший суффикс, который есть в боре - это `cabc` и `go` будет вести именно в него.

Что делает сам алгоритм? Находит `link[v]` и `go[v][c]` для всех позиций и символов.

Вот есть бор, будем идти по нему что-то типа [[BFS]] 

Тогда пусть у нас есть вершина `v`, есть символ `c` и если мы припишем к `v` символ `c`, то получим строку `u = vc`, хотим понять, чему равно `link[u]` (от строк меньшей длины мы уже всё знаем).

Тогда:

$$
link[u] = \begin{cases}
0, v = 0 \\
go[link[v]][c], v \ne 0
\end{cases}
$$
Ну в целом очевидно, поскольку мы берём наибольший суффикс $v$, приписываем к нему $c$ и смотрим наибольший суффикс от этого, который есть в боре.

Пусть это не максимальный суффикс, что тогда? Но тогда получается, что $link[v]$ должен быть больше, чем получился.

Собственно, как работает алгоритм?

```cpp
link[0] = -1; // для корня неопределён
for c in alphabet: 
	if (t[0].to[c] != -1) {
		go[0][c] = t[0].to[c];
	} else {
		go[0][c] = 0;	
	}
	std::queue<int> q;
	q.push(0);
	while (!q.empty()) {
		int v = q.front();
		q.pop();
		for (c in alphabet) {
			u = t[v].to[c];
			if (u == -1) continue; // если перехода нет
			link[u] = (v == 0 ? 0 : go[link[v][c]]); // определяем линк
			for d in alphabet:  // считаем go[u][d]
				if (t[u].to[d] != -1) {
					go[u][d] = t[u].to[d];
				}
				go[u][d] = go[link[u][d]];
			}
			q.push(u);
		}
	}
```

Теперь прежде чем решить исходную задачу сделаем 2 динамики:

`dp[v]` - количество терминальных вершин, среди списка `v`, `link[v]`,`link[link[v]]

`link[v]` - суффиксная ссылка.

Если мы рассмотрим множество суффиксных ссылок, то они образуют дерево (так как при взятии линка глубина уменьшается и они, очевидно, сводятся к корню). Тогда посчитать `dp[v]` можно просто динамикой по дереву.

Теперь `compressed[v]` - первая вершина из списка `link[v], link[link[v]]` - являющаяся терминальной. Это называется сжатая суффиксная ссылка.

Тогда как решать задачу?

Представим текст, как набор символов $t = t_{1}...t_{n}$

Встанем в корень $v_{0} = 0$ и будем ходить по `go`:

`v_j = go[v_j-1][t_j]`

Тогда замечание, что $v_{j}$ - максимальный суффикс строки $t_{1},..., t_{j}$, который есть в боре. Ну и что теперь делать? По сути, теперь чтоб найти терминальные вершины, нам надо просто делать `v`, `link[v]`, то есть в точность дпшка. Новое вхождение при добавлении символа $t_{j}$ получают в точности слова, достижимые из $t_{j}$ многократными прыжками по суффиксным ссылкам, тогда $ans += dp[v_{j}]$ - это решает первую задачу.

Для $v$ просмотреть $compressed[v]$, $compressed[compressed[v]]$ и получить все вхождения.

Оценим асимптотику.

В целом очевидно, что это $O(V * |\Sigma|)$, где $V$ - количество вершин бора.

Ну и плюс $|t|$ - размер текста

Получаем $O(V * |\Sigma| + |t|)$
