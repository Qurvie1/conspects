**Определение**. Эйлеров цикл - это цикл, проходящий по всем рёбрам [[Граф|графа]] ровно 1 раз.
Аналогично определяется путь.

**Определение**. Степень вершины $v$ - количество рёбер, инцидентных этой вершине. В случае ориентированного - сколько выходит или сколько входит.

Граф называется **эйлеровым** если в нём есть эйлеров цикл и **полуэйлеровым**, если есть путь но нет цикла.

**Критерий эйлеровости**

(неориентированный граф)
**Теорема**. Пусть $G$ - неориентированный граф.
В графе $G$ есть эйлеров цикл $\iff$ граф $G$ после удаления изолированных вершин становится связным и $\forall v$ $\deg v$ - чётна.

В графе $G$ есть эйлеров путь $\iff$ граф $G$ после удаления изолированных вершин становится связным и у всех вершин, кроме, может быть, двух, степень чётна.

(для ориентированных)
**Теорема**. Пусть $G$ - ориентированный граф
В $G$ есть эйлеров цикл $\iff$ граф $G$ после удаления изолированных вершин становится [[Алгоритм Косарайю|сильно связным]] и $\forall v$ $\deg_{+}(v) = \deg_{-}(v)$
В $G$ есть путь $\iff$ сильно связный после удаления изолированных вершин и у одной вершины исходящая больше на 1, чем входящая, а другой наоборот.

Докажем для ориентированного случая.
Сведём случай пути к циклу добавив ребро из $t$ в $s$ (как раз где нарушается равенство степеней).
$\implies$ очевидно, потому что если есть эйлеров цикл, то сколько раз из вершины выходим, столько же входим, иначе мы из какой-то вершины не выходим, то есть нет эйлерова цикла

В обратную сторону предъявим алгоритм
Сделаем [[Граф|DFS]] без запоминания, то есть пока мы видим ребро, по которому мы не ходили, идём по нему, но можем идти в вершины, где были.

Пусть $ptr[v]$ - номер первого неиспользованного ребра из вершины $v$.
Тогда алгоритм прост - пока есть неиспользованное ребро идём по нему.

```cpp
void Euler(int v, int parent_edge) {
	while (ptr[v] != g[v].size()) { // пока есть неиспользованные рёбра
		Edge l = g[v][ptr[v]]; // берём первое неиспользованное
		++ptr[v]; // увеличиваем счётчик
		Euler(l.second, l);  // запускаемся рекурсивно
	}
	order.push_back(oarent_edge); // берём последнее ребро при завершении рекурсии
}
std::reverse(order.begin(), order.end());
```

Почему алгоритм точно найдёт эйлеров цикл? Допустим, мы запускаемся от вершины $s$, тогда у нас рёбра закончатся точно тогда, когда мы вернёмся в $s$.

Почему? Поскольку входящая равна исходящей, то из любой промежуточной вершины $v$ мы сможем выбраться. А нарушается это как раз для вершины $s$, ведь из неё мы в принципе вышли, поэтому там дизбаланс степеней.
Поэтому первое добавленное ребро - ребро в $s$ (заканчивающее).

В силу алгоритма мы точно найдём все рёбра (то есть посетим все рёбра). Вопрос - в каком порядке.

Ну и дальше по аналогии, если у нас уже в $order$ добавлены рёбра от $t$ до $s$, тогда в этом случае, запуская $Euler(t)$ мы снова получим ребро в $t$, а у всех добавленных рёбер в $order$ есть свойство, что все вершины на пути из $s$ в $t$ уже со всеми просмотренными рёбрами (иначе бы мы его не добавили).
Асимптотика $O(V + E)$
