Есть строчка.

Тогда суффиксным массивом строки $s = s_{0}s_{1}...s_{n-1}$ называется перестановка $p_{0}p_{1}...p_{n-1}$ такая, что:

$$
S^{p_{0}} < S^{p_{1}} < ... < S^{p_{n-1}}
$$
$S^{p_{0}}$ - суффикс, начинающийся с позиции $p_{0}$.

$$
S^{j} = s_{j}s_{j+1}...s_{n-1}
$$
Опр. Longest common prefix (LCP) - наибольший префикс двух слов - длина их наибольшего общего префикса.

Обозначение:
$$
lcp_{i} = LCP(s^{p_{i}}, s^{p_{i+1}})
$$
Утверждение. Пусть $p_{l} = i$, $p_{r} = j$, причём $l < r$. Тогда:
$$
LCP(s^{i}, s^{j}) = \min_{k=l}^{r-l} lcp_{k}
$$
Ну в целом очевидно, мы берём просто по всем префиксам минимальное значение

Почему это так:

1. Очевидно, что $LCP(s^{i}, s^{j}) \geq x$ (правой части), просто из картинки
2. Пусть не выполняется равенство, то есть $\geq x + 1$.

Но тогда есть 2 строки у которых значение равно $x$ (между этими строчками).

Чего не может быть, а почему? Если например, у нас между этими строчками у какой-то строчки отличается символ от $s^{i}$ и $s^{j}$ (скажем, что меньше) $b < c$, но тогда этот суффикс должен быть выше, чем $s^{i}$. Аналогично, если $d > c$, тогда он должен быть ниже $s^{j}$.

Теперь мы можем решать следующую задачу.

Есть большая строка $s$ и нам поступают запросы типа $l_{1}, r_{1}$ - первая подстрока и $l_{2}, r_{2}$ - вторая подстрока, нужно сравнить их на равенство.
Мы можем делать это с помощью $LCP$
Мы умели делать это [[Полиномиальное хеширование|хэшами]], но теперь это можно сделать без коллизий.


То есть $LCP(s^{l_{1}}, s^{l_{2}}) \geq r_{1} - l_{1} + 1 ? YES : NO$

Как будем строить массив?

Приписываем к строке символ, который меньше всех символов строки.

Зациклим строку (символ, следующий за последним - это начальный).

Будем работать с циклическими подстроками строки $s$.

Тогда минимальный циклический сдвиг этой строки начинается с # .

Отсортируем все циклические сдвиги этой строки:

Например, для `abacaba#` будет:

```
#abacaba
a#abacab
aba#abac
abacaba#
acaba#ab
```

И теперь если мы обрубим все строчки на `#`, то мы и получим нужную перестановку суффиксов.

Будем сортировать подстроки длины $2^{k}$.

Также храним разбиения на классы эквивалентности. Каждой подстроке сопоставим число, при этом числа сравниваются как строки, если $s_{1} < s_{2}$, тогда и $a(s_{1}) < a(s_{2})$, где $a(s)$ - отображение из строк в числа (нумерация).

$p_{i}$ - начальный индекс подстроки длины $2^{k}$, которая стоит на $i$-ом месте в порядке сортировки.
$c_{i}$ - номер класса эквивалентности подстроки длины $2^{k}$, начинающийся в индексе $i$.

Пример: `abcabbc#`

Рассмотрим все подстроки длины $2$.

Тогда $p_{0} = 7$ (самая маленькая с решётки). Аналогично:
$p_{1} = 0, p_{2} = 3, p_{3} = 4, p_{4} = 1, p_{5} = 5$

Потом
$c_{7} = 0$ (наименьшая лексикографически строка с индексом 7).
$c_{0} = c_{3} = 1$ (строки равны)

$k = 0$ - сортировка символов, работает в целом [[Сортировки за линию|сортировка подсчётом]].

```cpp
s_0, ..., s_n
cnt[256];
for (int i = 0; i < n; ++i) {
	++cnt[s_i];
}
for (int i = 1; i < 256; ++i) {
	cnt[i] += cnt[i - 1]
}
for (int i = n; i > 0; --i) {
	p[--cnt[s[i]]] = i;
}
x = 0;
for (int i = 0; i < n; ++i) {
	if (i == 0 || s[p[i]] == s[p[i - 1]]) {
		c[p[i]] = x;
	} else {
		++x;
		c[p[i]] = x;
	}
}
```

Теперь как посчитать $2^{k+1}$, если мы знаем подстроки длины $2^{k}$.

Тогда мы можем просто разбить строку $2^{k+1}$ на 2 строки длинами $2^{k}$ и у нас будет как бы 2 символа $(c_{i}, c_{i+2^{k}})$ (то есть сортировка соответствующих классов эквивалентности)

Ну а сортировка пар - это по сути сортировка подсчётом делается. То есть сначала по вторым компонентам пар, а потом стабильно по первым.

По сути, первый шаг можно пропустить (то есть сортировку по вторым компонентам пар)

$$
p'[i] = (p[i] - 2^{k}) \mod n
$$

Тогда в целом, когда мы отсортируем до $2^{k} \geq n$ циклические строки, то потом мы можем просто обрубить на `#` и всё будет с кайфом.

Итого у нас $O(\lg n)$ итераций и сортировки линейные по $O(n)$ в сумме - $O(n\lg n)$

Теперь решим задачу $LCP$ - посчитаем массив $LCP$ собственно.

Посчитаем $pos$ - перестановку, обратную к $p$.

В каком смысле обратная: `pos[p[i]] = i;`

Тогда `pos[0]` - это место, где лежит вся строчка.

Пусть мы посчитали первые $l$ символов у каких-то двух суффиксов.

Тогда можно отбросить первые $l$ символов и остальные не поменяют порядок, если $l \geq 1$.

Если дальше символы равны, то будем увеличивать $l$.

Псеводкод:

```cpp
l = 0;
for (int i = 0; i < n; ++i) {
	if (pos[i] == n - 1) { l = 0; continue; }
	j = p[pos[i] + 1];
	l = max(l - 1, 0);
	while (s[i + l] ==  s[j + l]) {
		++l;
	}
	lcp[pos[i]] = l;
	
}
```