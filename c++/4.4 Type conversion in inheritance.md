Есть Base и Derived

struct Base {
int x;
}

struct Derived: Base {
int y = 2;
}
если у нас есть функция, которая применяет Base, то можно подсунуть наследника, вместо родителя.

void f(Base& b) {
std::cout << b.x;
}

по значению тоже (то есть не по ссылке)
тогда произойдёт слайсинг: будет неявно сгенерирован консруктор Base от Derived (то есть когда мы засунем Derived, то мы оттуда типа вытащим объект Base (создадим его копию)).

cast
Derived -> Base:
implicit, static, reinterpret можно везде, кроме reinterpret в копии (ну тут просто теория, так как мы туда ссылку передаём)
при этом при приватном наследовании везде наоборот CE, кроме reinterpret (и то, потому что реинтерпрет касту вообще похуй что происходит)

Base -> Derived - можно только статик каст и реинтерпрет каст (static и reinterpet)
как и приватное Derived -> Base

[[4.5 Multiple inheritance]]

