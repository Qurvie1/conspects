Мы хотим объединять [[13.4 Constraints and requirements|requirements]] в какие-то сущности.

```cpp
template <typename InputIter, typename Predicate>
InputIter find_if(InputIter beg, InputIter end, Predicate p) {

}
```

И вот вроде мы хотим принимать только input iterators, но мы сюда принимаем всё подряд, но хотим принимать только input iterators.

Набор requirements и будет называться **концептом**.

```cpp
template <typename T>
concept InputIterator = requires(T it) {
	++it;
	*it;
};

template <typename It, typename Predicate>
requires InputIterator<It>
```

Мы разобрали [[13.5 Requires-expressions|requirements]] разные, есть ещё и **compound requirements**.

Это когда для экспрешена проверяем удовлетворяемость концепту:
```cpp
{++it} -> concept ...
```

Первый элемент в концепт подставляется сам:

```cpp
{*it} -> std::convertible_to<typename std::iterator_traits<T>::value_type>;
```

То есть мы проверяем приводим ли результат разыменования итератора к `value_type`.

Теперь мы можем писать:
```cpp
template <typename It> // не так, а:
template <InputIterator It> // то есть мы проверяем на концепт
```

Можно проверять:
```cpp
auto my_find_if(InputIterator auto beg, InputIterator auto end)
```
Типа они могут быть разных типов.