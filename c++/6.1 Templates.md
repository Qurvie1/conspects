мы хотим для любого типа T определить что-то
typename = class по сути

можно объявлять шаблонные классы

а можно даже шаблонный юзинг

template <typename* T>
using mymap = std::map<T, T, std::greater<T*>>;

и по сути, можно сделать
mymap<T*> m; - и это будет то же самое

шаблоны - это кодогенерация (паттерн, по которому делается код)

допустим, что мы делаем:
int a = 0;
long long b = 1;
swap(a, b)

по сути, компилятор не понимает какую версию взять, в этом и вся проблема.
[[6.2 Template overloading]]
