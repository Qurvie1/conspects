template <typename* T>

void f(T x) {}

void f(int x) {}

int main() {
int x = 0;
f(x)
}

это логично, что выберется вторая, потому что мы, как компилятор, не хотим делать новую копию функции (то есть более частное взять)

если компилятор может создать подходящую версию, то он предпочтет её.

можно делать аргументы по умолчанию

пусть есть f(int x)
f(int& x)
что вызовется? - нет разницы, поэтому фактически, это работает одинаково, то есть ссылки понижаются.
но если вывести f(1), то будет 2

[[6.3 Template specialization]]
