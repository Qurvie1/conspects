15.1.1 по индукции банально
15.1.2
ну например, если жадная стратегия будет нам говорить о том, что нужно брать соседние или например, если мы хотим отрезать только i, то нужно по сути (в оптимуме) на самом деле отрезать только половину и так далее
15.1.3.
по сути, если мы рассматриваем нисходящую реализацию, то теперь, при разрезании стержня нужно ещё доплатить c, поэтому мы выбираем по сути:

if r(n) >= 0
return r[n]
if n == 0;
q = 0;
q = -inf
for i = 1 to n:
q = max(q, pi - c + memoized-cut-rod-aux(p, n - i, r))
ну то есть по сути поправку на c

15.1.4 просто добавить ещё условие
15.1.5 база
dp[i] = dp[i - 1] + dp[i - 2], dp[0] = 1, dp[1] = 1

15.2.1
база
15.2.2
решено в алгосах уже, просто считаем рекурсивно для i, k и k + 1, j, если мы НЕ считали ещё (то есть если в dp == -inf)
15.2.3.
ну лень, просто по индукции можно
15.2.4.
n^2 вершин и каждая подзадача то есть при выборе i, j (их всего n^2) требует ещё выбора n - 1 для k
15.2.5. ну в целом тоже по индукции, либо как-то конструктивно несложно показывается
15.2.6 по индукции 