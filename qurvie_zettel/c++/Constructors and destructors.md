class Complex {
Complex(double real) {
re = real;
}
}
Complex c(5.0);
Complex c2 = 6.0;
Complex c3{7.0}
это всё конструкторы
ВАЖНО! 
Инициализировать лучше перед входом в тело конструктора:
Member initializer list
Complex(double real) : re(real) {}
Complex(double re, double im): re(re), im(im) {}
в чём сложность, если мы создадим сложный объект и потом сделаем присваивание, то есть мы не делаем типа инициализация 0 и присваивание, а просто сразу инициализируем
(то есть изначально default -> value, а так сразу value)
и второе очевидно быстрее

в чём смысл объявлять методы в .h, а определять в .cpp? чтоб не было redifintion, когда будем делать много include

в идеале в списке инициализации записывать в порядке ввода переменных

если есть хотя бы один конструктор, то агрегатная инициализация перестаёт работать работает уже конструктор

есть member initializer lists, а есть другой уже

типа мы хоти делать String s = {'a', 'b', 'c'}

std::initializer_list - begin и end есть
String(std::initializer_lists<char!> list) : arr(new char[list.size()], sz(list.size())) {
std::copy(list.begin(), list.end(), arr)
arr[sz] = '\0*';
если есть хотя бы один конструктор от inizializer_list то берётся она, если ни одна не подходит, то берётся inizializer_list (если с фигурными скобочками).
explicity declared - явно объявленный, implicity defined - неявно определённый


типа initializer_list помогает нам получить кучу значений типа {a, b, c}
}

иногда конструктор по умолчанию не работает, например, если поле - ссылка или класс, ещё если поле - константа и мы её не инициализируем

Интересно, что если делать константную ссылку типа r(5), то в классе это работать не будет, поскольку это работает только в функции.

Деструкторы.
Функция, которая вызывается перед выходом из области видимости
Обычно нужно типа удаление памяти
Деструкторы вызываются в обратном порядке объявления

Конструктор копирования - String(const String& other): arr(new char[other.cap]), sz(other.sz), cap(other.cap) {
  memcpy(arr, other.arr, sz + 1)
  arr[sz] = '0';
  memmove - корректно работает, даже если пересекаются поля\
}

делегирующий коструктор - если мы делаем всё то же, что и в другом конструкторе + что-то ещё, то можно сказать типа сделай это, а потом ещё 

String(size_t n, char c): String(n) { - это значит сделай всё то же самое, а потом доделай 
memcpy
}

String() = delete - запрет вызова функции
[[Rule of three]]
