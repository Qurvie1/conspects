если в классе есть хотя бы одна виртуальная функция, то sizeof(Base) = 8 (из-за поинтера)
в vtable хранятся как виртуальные предки, так и виртуальные методы.

если у нас есть виртуальная функция, то у объекта должен быть указатель на vtable - таблицу виртуальных функций, которая хранится в статической памяти 1 на тип, где перечислены адреса функций этого типа.
там хранятся как виртуальные предки, так и методы.
struct Base {
virtual int f() {}
void h() {};
int x;
}

vtable Base
что там хранится: адрес Base::f + адрес Base typeinfo
ptr -> vtable

Base typeinfo - вся инфа о типе

Base:
ptr, x, выравнивание

struct Derived: Base {
void f() override {}
virtual void g()
int y
}

пусть есть f - виртуальная, h - невиртуальная, x - метод
sizeof Base = 16 - очевидно

Base:
ptr, x, выравнивание

объект Derived:
ptr, x, y

по сути, количество методов не влияет на память, но вот виртуальные функции влияют

но как выглядит Derived vtable
&Derived typeinfo, &Derived::f, &Derived::g
как работает вызов виртуальной функции?
Derived d;
Base& b = d
b.f()
сначала мы идём по поинтеру, с которого начинается наш объект и чё там вообще.
мы получаем vtable base, но потом разыменовывается указатель в base и мы идём уже в derived
ну и динамик каст работает так же, только смотрит на typeinfo постоянно

Granny
Mom
Son
в Mom virtual void f() {}

void f() override

как выглядит Son

ptr (потом бабушка) g, m, s

что происходит, когда делаем каст от сына к бабушке

[[5.6 Memory layout of polymorphic objects of multiple inheritance]]
