struct Base {
int x;
void f() {
std::cout << 1;
}
}

struct Derived: Base {
int y;
void f() {
std::cout << 2;
}
}

конечно будет приоритетнее локальное, поэтому выведется на f() - 2

если даже f(double)
и f(int)
то всё равно будет 2
так как имена из бейза даже не смотрятся
если есть в локальной области
если мы хотим обратиться к родительскому методу, то нужно:
d.Base::f();
можно делать
using Base::f; (но выигрывает всё равно локальная)
protected функция в родителе тоже будет работать
полезная штука:
private:
using Base::f;
public:
f
d.f - нельзя
d.Base::f - можно!
сначала выбирается область видимости, потом перегрузка, потом уже приватность

[[4.3 Inheritance memory layout]]
