struct Base {
int x;
Base(int x): x(x) {}
}
struct Derived: Base {
double y;
Derived(double y): Base(0), y(y) {}
конструктор в конструкторе
}

sizeof(Derived) = 16;

если поле пустое, то структура весит 1

EBO Empty Base Optimization
на самом деле это 8

Derived d = 3.14 - CE (сначала создаётся объект родителя, потом наследник, поэтому непонятно чем инициализировать по умолчанию)

конструтор - сначала инициализируется родитель, потом сын, деструкторы в обратном направлении работает.
using Base::Base - юзинг конструктора (это нужно, чтоб постоянно не писать какой-то конструктор)
но конструкторы копирования не наследуются (иначе появляется неявный каст родителя к наследнику)


когда мы разрушаем, то сначала работает деструктор наследника, потом уничтожаются поля наследника, потом отрабатывает деструктор родителя, потом уничтожаются поля родителя.

опять же, если мы делаем конструктор наследника, то нужно сначала объяснить как создавать родителя:
Base(int x): x(x)
Derived(int y): Base(0), y(y) - то есть сначала мы инициализируем базу, а потом уже всё таки derived

[[4.4 Приведение типов]]
